import { Schema, TypeAST } from '@/types';
import { getRefName, getSchemaName, getTsType } from '@/utils/generate-utils';
import { getJsdoc } from '@/utils/jsdoc';
import { AUTOGENERATED_COMMENT } from '../template/tmp';

function generateTypes(types: TypeAST[]): string {
  let code = AUTOGENERATED_COMMENT;
  try {
    code += types.reduce((prev, { name: _name, schema, description }) => {
      const name = getSchemaName(_name);
      prev += `
        ${getJsdoc({
          ...schema,
          description: description || schema?.description,
          deprecated: schema?.deprecated ? schema?.['x-deprecatedMessage'] || String(schema?.deprecated) : undefined,
        })}
        ${getTypeDefinition(name, schema, types)}
        `;

      return prev;
    }, '');

    return code;
  } catch (error) {
    console.error({ error });
    return '';
  }
}

function getTypeDefinition(name: string, schema: Schema = {}, types: TypeAST[]): string {
  const {
    type,
    enum: Enum,
    'x-enumNames': enumNames,
    allOf,
    oneOf,
    items,
    $ref,
    additionalProperties,
    properties,
  } = schema;

  if (Enum) {
    return `export enum ${name} {${Enum.map(
      (e, index) => `${enumNames ? enumNames[index] : JSON.stringify(e)}=${JSON.stringify(e)}`,
    )}}`;
  }

  if (allOf || oneOf) {
    return `export type ${name} = ${getTsType(schema, types)}`;
  }

  if (type === 'array' && items) {
    return `export type ${name} = ${getTsType(items, types)}[]`;
  }

  if ($ref) {
    return `export type ${name} = ${getRefName($ref)}`;
  }

  if (type === 'object') {
    const typeObject = getTsType(schema, types);

    if ((additionalProperties || properties) && !oneOf) {
      return `export interface ${name} ${typeObject}`;
    }

    return `export type ${name} = ${typeObject}`;
  }

  if (type === 'string') {
    return `export type ${name} = ${type}`;
  }

  return `export type ${name} = any`;
}

export { generateTypes };
